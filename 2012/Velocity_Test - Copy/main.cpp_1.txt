#include <iostream>
#include <allegro.h>
#include <winalleg.h>
#include <stdio.h>
#include <math.h>
#include "Projectile.h"

#define GREY          makecol(128, 128, 128)
#define WHITE         makecol(255, 255, 255)
#define RED           makecol(255,   0,   0)
#define GREEN         makecol(  0, 255,   0)
#define BLUE          makecol(  0,   0, 255)
#define YELLOW        makecol(255, 255,   0)
#define ORANGE        makecol(255, 128,   0)
#define CYAN          makecol(  0, 255, 255)
#define PURPLE        makecol(255,   0, 255)
#define LIGHT_BLUE    makecol(128, 128, 255)
#define PINK          makecol(255, 128, 128)
#define LIGHT_GREEN   makecol(128, 255, 128)

double uGc = 6.673e-011;                                    //Universal Gravitational Constant = 6.67300 * 10^-11
const double pi = 3.14159265358979;                         //To 15 digits  For conversion of degrees and raidans
double Time = 0;                                            //Measure of time elapsed in seconds

using namespace std;

BITMAP* Buffer;

double Space_Scale = 1;
double Time_Scale = 1;

void Refresh_Pos(Projectile &P){
    P.x += P.xVel;
    P.xVel += P.xAccel;

    P.y += P.yVel;
    P.yVel += P.yAccel;
}

void Gravity(Projectile &P1, Projectile &P2){

    cout << P1.x << " \t\t " << P1.xAccel << "\t\t + \t\t" << (uGc * P2.mass) / ((P2.x - P1.x) * fabs(P2.x - P1.x)) << endl;
    P1.xAccel += (uGc * P2.mass) / ((P2.x - P1.x) * fabs(P2.x - P1.x));
    P2.xAccel += (uGc * P1.mass) / ((P2.x - P1.x) * fabs(P2.x - P1.x));

    P1.yAccel += (uGc * P2.mass) / ((P2.y - P1.y) * fabs(P2.y - P1.y));
    P2.yAccel += (uGc * P1.mass) / ((P2.y - P1.y) * fabs(P2.y - P1.y));
}



int main()
{
    allegro_init();                                         //Allegro thing
    install_keyboard();                                     //Allegro thing
    //install_timer();                                      //Allegro thing
    set_gfx_mode(GFX_AUTODETECT_WINDOWED,640,480,0,0);      //Allegro thing
    Buffer = create_bitmap(640, 480);                       //Allegro thing (sort of)

    readkey();                                              //Allegro way of saying system("PAUSE");

    Space_Scale = 1;                                        //1 pixel = n meters
    Time_Scale = 25;                                        //Program updates n times per second; ~~INVERSE RELATIONSHIP~~
//#######################################################################################################################
    Projectile Man;

    Man.radius = 5;
    Man.Hue = PINK;
    Man.mass = 75; //previously m=250000

    Man.x = 209;
    Man.xVel = 0 / Space_Scale / Time_Scale;                //Meters per second, accounting for Time_ and Space_ Scale.
    Man.xAccel = 0 / Space_Scale / Time_Scale;              //Meters per second per secpnd "    "

    Man.y = 240;
    Man.yVel = 0 / Space_Scale / Time_Scale;
    Man.yAccel = 0 / Space_Scale / Time_Scale;
//#######################################################################################################################
    Projectile Phobos;

    Phobos.radius = 11100;
    Phobos.Hue = RED;                                       //previously makecol(200, 150, 137)
    Phobos.mass = 1.072e+016;                               //previously m=800000

    Phobos.x = 600;//11700
    Phobos.xVel = 0 / Space_Scale / Time_Scale;             //n pixels/sec is proportional to 10n m/s
    Phobos.xAccel = 0 / Space_Scale / Time_Scale;           // Meters per second, once more

    Phobos.y = 240;
    Phobos.yVel = 0 / Space_Scale / Time_Scale;
    Phobos.yAccel = 0 / Space_Scale / Time_Scale;
//#######################################################################################################################

    while(!key[KEY_ESC]){
        clear_to_color(Buffer,makecol(0, 0, 0));
        circlefill(Buffer, Phobos.x, Phobos.y, Phobos.radius, Phobos.Hue);          //DRAW PROJECTILE 1 to buffer
        circlefill(Buffer, Man.x, Man.y, Man.radius, Man.Hue);                      //DRAW PROJECTILE 2 to buffer


        Refresh_Pos(Man);                                   //Feed Man object into Refresh_Pos function
        Refresh_Pos(Phobos);                                //Do the same with Phobos (and theoretically every other projectile

        Gravity(Man, Phobos);

        blit(Buffer, screen, 0, 0, 0, 0, Buffer->w, Buffer->h);                     //Double-buffer added
        Sleep(1000 / Time_Scale);                           //All other values are increased by a value of 1000/n
        Time += 1/Time_Scale;
        //if((Man.x >= Phobos.x - Phobos.radius) && (Man.xAccel > 0)) readkey();
    }
    cout << endl << endl << Time << " seconds passed." << endl;

    readkey();

    return 0;
}
END_OF_MAIN()
